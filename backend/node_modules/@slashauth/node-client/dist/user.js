"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserController = void 0;
const query_1 = require("./query");
const strings_1 = require("./utils/strings");
// TODO: Need to add:
// - How do we add a user to an org?
// - How can we delete an org?
class UserController {
    constructor(client_id, client_secret, apiClient) {
        this.client_id = client_id;
        this.client_secret = client_secret;
        this.apiClient = apiClient;
    }
    async validateToken({ token, }) {
        try {
            const resp = await this.apiClient.get(`/validate_token`, {
                queryParameters: {
                    params: {
                        client_id: this.client_id,
                        token,
                    },
                },
            });
            if (!resp || !resp.statusCode || resp.statusCode !== 200) {
                throw new Error('token is not valid');
            }
            const encodedClaims = token.split('.')[1];
            if (!encodedClaims) {
                throw new SyntaxError('malformed token');
            }
            const decodedClaims = JSON.parse((0, strings_1.base64Decode)(encodedClaims));
            let isUserID = false;
            if (decodedClaims.sub.startsWith('user.')) {
                isUserID = true;
            }
            const getWalletAddress = async () => {
                var _a, _b;
                if (isUserID) {
                    const user = await this.getUserByID({ userID: decodedClaims.sub });
                    if ((_a = user.result) === null || _a === void 0 ? void 0 : _a.data.wallet) {
                        return (_b = user.result) === null || _b === void 0 ? void 0 : _b.data.wallet;
                    }
                    else {
                        return null;
                    }
                }
                else {
                    // We already have the wallet address, return.
                    return decodedClaims.sub;
                }
            };
            return {
                userID: isUserID ? decodedClaims.sub : undefined,
                address: isUserID ? undefined : decodedClaims.sub,
                clientID: decodedClaims.client_id,
                issuedAt: decodedClaims.iat,
                expiresAt: decodedClaims.exp,
                issuer: decodedClaims.iss,
                walletType: decodedClaims.wallet_type,
                getWalletAddress,
            };
        }
        catch (err) {
            throw err;
        }
    }
    // TODO: Update SA_Backend to accept userID parameter
    async hasRole({ userID, role, organizationID, }) {
        const encodedRole = Buffer.from(role, 'utf8').toString('base64');
        const urlParams = (0, query_1.signQuery)({
            input: {
                userID,
                role: encodedRole,
                encoded: 'true',
            },
            secret: this.client_secret,
        });
        const urlPath = (0, strings_1.getURLPath)(this.client_id, 'has_role', true, organizationID);
        return await this.apiClient.get(urlPath, {
            queryParameters: { params: urlParams },
        });
    }
    async hasRoleWallet({ address, role, organizationID, }) {
        const encodedRole = Buffer.from(role, 'utf8').toString('base64');
        const urlParams = (0, query_1.signQuery)({
            input: {
                address,
                role: encodedRole,
                encoded: 'true',
            },
            secret: this.client_secret,
        });
        const urlPath = (0, strings_1.getURLPath)(this.client_id, 'has_role', true, organizationID);
        return await this.apiClient.get(urlPath, {
            queryParameters: { params: urlParams },
        });
    }
    async hasRoleToken({ token, role, organizationID, }) {
        const encodedRole = Buffer.from(role, 'utf8').toString('base64');
        const urlParams = {
            role: encodedRole,
            encoded: 'true',
        };
        const urlPath = (0, strings_1.getURLPath)(this.client_id, 'has_role', false, organizationID);
        return this.apiClient.get(urlPath, {
            additionalHeaders: {
                Authorization: `Bearer ${token}`,
            },
            queryParameters: {
                params: urlParams,
            },
        });
    }
    async getOrgMemberships({ userID, }) {
        const urlParams = (0, query_1.signQuery)({
            input: {
                userID,
            },
            secret: this.client_secret,
        });
        return this.apiClient.get(`/s/${this.client_id}/org_memberships`, {
            queryParameters: {
                params: urlParams,
            },
        });
    }
    async getUserByID({ userID, organizationID, }) {
        const input = {};
        if (organizationID) {
            input.organizationID = organizationID;
        }
        const urlParams = (0, query_1.signQuery)({
            input,
            secret: this.client_secret,
        });
        const urlPath = (0, strings_1.getURLPath)(this.client_id, `users/${userID}`, true, organizationID);
        return this.apiClient.get(urlPath, {
            queryParameters: {
                params: urlParams,
            },
        });
    }
    async getUsers({ organizationID, cursor, }) {
        const input = {};
        if (organizationID) {
            input.organizationID = organizationID;
        }
        if (cursor) {
            input.cursor = cursor;
        }
        const urlParams = (0, query_1.signQuery)({
            input,
            secret: this.client_secret,
        });
        const urlPath = (0, strings_1.getURLPath)(this.client_id, 'users', true, organizationID);
        return this.apiClient.get(urlPath, {
            queryParameters: {
                params: urlParams,
            },
        });
    }
    async createUser({ wallet, email, phoneNumber, nickname, metadata, }) {
        const body = (0, query_1.signBody)({
            input: {
                wallet,
                email,
                phoneNumber,
                nickname,
                metadata,
            },
            secret: this.client_secret,
        });
        const url = `/s/${this.client_id}/users`;
        return await this.apiClient.create(url, body);
    }
    async updateUserMetadata({ userID, nickname, metadata, organizationID, }) {
        const body = (0, query_1.signBody)({
            input: {
                nickname,
                metadata,
            },
            secret: this.client_secret,
        });
        const urlPath = (0, strings_1.getURLPath)(this.client_id, `users/${userID}`, true, organizationID);
        return await this.apiClient.replace(urlPath, body);
    }
    async addAssignedRole({ userID, role, organizationID, }) {
        const body = (0, query_1.signBody)({
            input: {
                role,
            },
            secret: this.client_secret,
        });
        const urlPath = (0, strings_1.getURLPath)(this.client_id, `users/${userID}/assigned_role`, true, organizationID);
        return await this.apiClient.create(urlPath, body);
    }
    async removeAssignedRoleFromUser({ userID, role, organizationID, }) {
        const encodedRole = Buffer.from(role, 'utf8').toString('base64');
        const urlParams = (0, query_1.signQuery)({
            input: {
                role: encodedRole,
            },
            secret: this.client_secret,
        });
        const urlPath = (0, strings_1.getURLPath)(this.client_id, `users/${userID}/assigned_role`, true, organizationID);
        return await this.apiClient.del(urlPath, {
            queryParameters: {
                params: urlParams,
            },
        });
    }
}
exports.UserController = UserController;
//# sourceMappingURL=user.js.map
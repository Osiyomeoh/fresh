import { SlashAuthClientOptions, CacheLocation, IdToken, Account, GetAccountOptions, GetIdTokenClaimsOptions, GetTokensOptions, GetTokensVerboseResponse, LogoutOptions, LogoutUrlOptions, LoginNoRedirectNoPopupOptions, GetNonceToSignOptions, GetAppConfigResponse, ExchangeTokenOptions, MagicLinkLoginOptions, GoogleLoginOptions } from '../shared/global';
import { ObjectMap } from '../shared/utils/object';
/**
 * SlashAuth SDK for Single Page Applications using no-redirect, no popup flow.
 */
export default class SlashAuthClient {
    private options;
    private readonly transactionManager;
    private readonly cacheManager;
    private readonly customOptions;
    private readonly domainUrl;
    private readonly tokenIssuer;
    private readonly defaultScope;
    private readonly scope;
    private readonly cookieStorage;
    private readonly sessionManager;
    private readonly sessionCheckExpiryDays;
    private readonly orgHintCookieName;
    private readonly isAuthenticatedCookieName;
    private readonly nowProvider;
    private readonly httpTimeoutMs;
    private continuedInteraction;
    cacheLocation: CacheLocation;
    private worker;
    constructor(options: SlashAuthClientOptions);
    initialize(): Promise<void>;
    private _url;
    private _authorizeUrl;
    private _authorizeContinuedUrl;
    private _verifyIdToken;
    private _parseNumber;
    private _processOrgIdHint;
    /**
     * ```js
     * const user = await slashauth.getAccount();
     * ```
     *
     * Returns the user information if available (decoded
     * from the `id_token`).
     *
     * If you provide an audience or scope, they should match an existing Access Token
     * (the SDK stores a corresponding ID Token with every Access Token, and uses the
     * scope and audience to look up the ID Token)
     *
     * @typeparam TUser The type to return, has to extend {@link User}.
     * @param options
     */
    getAccount<TAccount extends Account>(options?: GetAccountOptions): Promise<TAccount | undefined>;
    /**
     * ```js
     * const claims = await slashauth.getIdTokenClaims();
     * ```
     *
     * Returns all claims from the id_token if available.
     *
     * If you provide an audience or scope, they should match an existing Access Token
     * (the SDK stores a corresponding ID Token with every Access Token, and uses the
     * scope and audience to look up the ID Token)
     *
     * @param options
     */
    getIdTokenClaims(options?: GetIdTokenClaimsOptions): Promise<IdToken | undefined>;
    /**
     * ```js
     * await slashauth.checkSession();
     * ```
     *
     * Check if the user is logged in using `getTokens`. The difference
     * with `getTokens` is that this doesn't return a token, but it will
     * pre-fill the token cache.
     *
     * This method also heeds the `slashauth.{clientId}.is.authenticated` cookie, as an optimization
     *  to prevent calling Slashauth unnecessarily. If the cookie is not present because
     * there was no previous login (or it has expired) then tokens will not be refreshed.
     *
     * It should be used for silently logging in the user when you instantiate the
     * `SlashAuthClient` constructor. You should not need this if you are using the
     * `createSlashAuthClient` factory.
     *
     * **Note:** the cookie **may not** be present if running an app using a private tab, as some
     * browsers clear JS cookie data and local storage when the tab or page is closed, or on page reload. This effectively
     * means that `checkSession` could silently return without authenticating the user on page refresh when
     * using a private tab, despite having previously logged in. As a workaround, use `getTokens` instead
     * and handle the possible `login_required` error.
     *
     * @param options
     */
    checkSession(options?: GetTokensOptions): Promise<boolean>;
    /**
     * Fetches a new access token and returns the response from the /oauth/token endpoint, omitting the refresh token.
     *
     * @param options
     */
    getTokens(options: GetTokensOptions & {
        detailedResponse: true;
    }): Promise<GetTokensVerboseResponse>;
    /**
     * Fetches a new access token and returns it.
     *
     * @param options
     */
    getTokens(options?: GetTokensOptions): Promise<string | null>;
    private _getTokens;
    /**
     * Fetches whether the user has the provided role
     *
     * @param options
     * @returns
     */
    hasRole(roleName: string): Promise<boolean>;
    /**
     * Fetches whether the user has the provided role
     *
     * @param options
     * @returns
     */
    hasOrgRole(organizationID: string, roleName: string): Promise<boolean>;
    /**
     * Fetches the role metadata if a user has access
     *
     * @param options
     * @returns
     */
    getRoleMetadata(roleName: string): Promise<ObjectMap>;
    getAppConfig(): Promise<GetAppConfigResponse>;
    getUserAccountSettings(userID: string): Promise<import("../shared/global").UserAccountSettings>;
    patchUserAccountSettings({ id, ...userAttributes }: {
        id: string;
        defaultProfileImage?: string;
        name?: string;
    }): Promise<{
        defaultProfileImage: string;
        name: string;
    }>;
    deleteConnection(userID: string, connectionID: string): Promise<void>;
    uploadBlob(file: File, userID: string): Promise<{
        id: string;
    }>;
    getNonceToSign(options: GetNonceToSignOptions): Promise<string>;
    exchangeToken(options: ExchangeTokenOptions): Promise<any>;
    googleLogin(options: GoogleLoginOptions): Promise<void>;
    magicLinkLogin(options: MagicLinkLoginOptions): Promise<void>;
    /**
     *
     * @returns
     */
    walletLoginInPage(options: LoginNoRedirectNoPopupOptions): Promise<void>;
    private processToken;
    /**
     * ```js
     * const isAuthenticated = await slashauth.isAuthenticated();
     * ```
     *
     * Returns `true` if there's valid information stored,
     * otherwise returns `false`.
     *
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * ```js
     * await slashauth.buildLogoutUrl(options);
     * ```
     *
     * Builds a URL to the logout endpoint using the parameters provided as arguments.
     * @param options
     */
    buildLogoutUrl(options?: LogoutUrlOptions): string;
    /**
     * ```js
     * slashauth.logout();
     * ```
     *
     * Clears the application session and performs a redirect to `/auth/logout`, using
     * the parameters provided as arguments, to clear the Slashauth session.
     *
     * **Note:** If you are using a custom cache, and specifying `localOnly: true`, and you want to perform actions or read state from the SDK immediately after logout, you should `await` the result of calling `logout`.
     *
     * If the `federated` option is specified it also clears the Identity Provider session.
     * If the `localOnly` option is specified, it only clears the application session.
     * It is invalid to set both the `federated` and `localOnly` options to `true`,
     * and an error will be thrown if you do.
     *
     * @param options
     */
    logout(options?: LogoutOptions): Promise<void>;
    private _getTokenUsingRefreshToken;
    private _getEntryFromCache;
}

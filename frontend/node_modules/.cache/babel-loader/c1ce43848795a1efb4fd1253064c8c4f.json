{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAsyncMiddleware = void 0;\n/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\n\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback = null;\n    let nextWasCalled = false; // This will be called by the consumer's async middleware.\n\n    const asyncNext = async () => {\n      nextWasCalled = true; // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n      // eslint-disable-next-line node/callback-return\n\n      next(runReturnHandlersCallback => {\n        // This callback comes from JsonRpcEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\n\nexports.createAsyncMiddleware = createAsyncMiddleware;","map":{"version":3,"mappings":";;;;;;AAgBA;;;;;;;;;;;;;;;;;;AAiBA,SAAgBA,qBAAhB,CACEC,eADF,EAC+C;EAE7C,OAAO,OAAOC,GAAP,EAAYC,GAAZ,EAAiBC,IAAjB,EAAuBC,GAAvB,KAA8B;IACnC;IACA;IACA;IACA,IAAIC,kBAAJ;IACA,MAAMC,WAAW,GAAG,IAAIC,OAAJ,CAAaC,OAAD,IAAY;MAC1CH,kBAAkB,GAAGG,OAArB;IACD,CAFmB,CAApB;IAIA,IAAIC,qBAAqB,GAAY,IAArC;IACA,IAAIC,aAAa,GAAG,KAApB,CAVmC,CAYnC;;IACA,MAAMC,SAAS,GAAG,YAAW;MAC3BD,aAAa,GAAG,IAAhB,CAD2B,CAG3B;MACA;MACA;;MACAP,IAAI,CAAES,yBAAD,IAA8B;QACjC;QACAH,qBAAqB,GAAGG,yBAAxB;QACAP,kBAAkB;MACnB,CAJG,CAAJ;MAKA,MAAMC,WAAN;IACD,CAZD;;IAcA,IAAI;MACF,MAAMN,eAAe,CAACC,GAAD,EAAMC,GAAN,EAAWS,SAAX,CAArB;;MAEA,IAAID,aAAJ,EAAmB;QACjB,MAAMJ,WAAN,CADiB,CACE;;QAClBG,qBAA+C,CAAC,IAAD,CAA/C;MACF,CAHD,MAGO;QACLL,GAAG,CAAC,IAAD,CAAH;MACD;IACF,CATD,CASE,OAAOS,KAAP,EAAc;MACd,IAAIJ,qBAAJ,EAA2B;QACxBA,qBAA+C,CAACI,KAAD,CAA/C;MACF,CAFD,MAEO;QACLT,GAAG,CAACS,KAAD,CAAH;MACD;IACF;EACF,CA3CD;AA4CD;;AA/CDC","names":["createAsyncMiddleware","asyncMiddleware","req","res","next","end","resolveNextPromise","nextPromise","Promise","resolve","returnHandlerCallback","nextWasCalled","asyncNext","runReturnHandlersCallback","error","exports"],"sources":["../src/createAsyncMiddleware.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
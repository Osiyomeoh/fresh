{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst util_1 = require(\"../util\");\n/**\n *\n * @param plainText string to be encrypted\n * @param secret hex representation of 32-byte secret\n * returns hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n * encrypted plainText.\n */\n\n\nasync function encrypt(plainText, secret) {\n  if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n  const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n  const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n    name: \"aes-gcm\"\n  }, false, [\"encrypt\", \"decrypt\"]);\n  const enc = new TextEncoder(); // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n\n  const encryptedResult = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv: ivBytes\n  }, secretKey, enc.encode(plainText));\n  const tagLength = 16;\n  const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n  const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n  const authTagBytes = new Uint8Array(authTag);\n  const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n  const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);\n  return (0, util_1.uint8ArrayToHex)(concatted);\n}\n\nexports.encrypt = encrypt;\n/**\n *\n * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n * @param secret hex string representation of 32-byte secret\n *\n * TODO: Update rxjs for promises\n */\n\nfunction decrypt(cipherText, secret) {\n  if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n  return new rxjs_1.Observable(subscriber => {\n    void async function () {\n      const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n        name: \"aes-gcm\"\n      }, false, [\"encrypt\", \"decrypt\"]);\n      const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n      const ivBytes = encrypted.slice(0, 12);\n      const authTagBytes = encrypted.slice(12, 28);\n      const encryptedPlaintextBytes = encrypted.slice(28);\n      const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);\n      const algo = {\n        name: \"AES-GCM\",\n        iv: new Uint8Array(ivBytes)\n      };\n\n      try {\n        const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n        const decoder = new TextDecoder();\n        subscriber.next(decoder.decode(decrypted));\n        subscriber.complete();\n      } catch (err) {\n        subscriber.error(err);\n      }\n    }();\n  });\n}\n\nexports.decrypt = decrypt;","map":{"version":3,"names":["Object","defineProperty","exports","value","decrypt","encrypt","rxjs_1","require","util_1","plainText","secret","length","Error","ivBytes","crypto","getRandomValues","Uint8Array","secretKey","subtle","importKey","hexStringToUint8Array","name","enc","TextEncoder","encryptedResult","window","iv","encode","tagLength","authTag","slice","byteLength","encryptedPlaintext","authTagBytes","encryptedPlaintextBytes","concatted","uint8ArrayToHex","cipherText","Observable","subscriber","encrypted","concattedBytes","algo","decrypted","decoder","TextDecoder","next","decode","complete","err","error"],"sources":["C:/Users/USER/Documents/demo-react/node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst util_1 = require(\"../util\");\n/**\n *\n * @param plainText string to be encrypted\n * @param secret hex representation of 32-byte secret\n * returns hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n * encrypted plainText.\n */\nasync function encrypt(plainText, secret) {\n    if (secret.length !== 64)\n        throw Error(`secret must be 256 bits`);\n    const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n    const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), { name: \"aes-gcm\" }, false, [\"encrypt\", \"decrypt\"]);\n    const enc = new TextEncoder();\n    // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n    const encryptedResult = await window.crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: ivBytes,\n    }, secretKey, enc.encode(plainText));\n    const tagLength = 16;\n    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n    const authTagBytes = new Uint8Array(authTag);\n    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n    const concatted = new Uint8Array([\n        ...ivBytes,\n        ...authTagBytes,\n        ...encryptedPlaintextBytes,\n    ]);\n    return (0, util_1.uint8ArrayToHex)(concatted);\n}\nexports.encrypt = encrypt;\n/**\n *\n * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n * @param secret hex string representation of 32-byte secret\n *\n * TODO: Update rxjs for promises\n */\nfunction decrypt(cipherText, secret) {\n    if (secret.length !== 64)\n        throw Error(`secret must be 256 bits`);\n    return new rxjs_1.Observable(subscriber => {\n        void (async function () {\n            const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), { name: \"aes-gcm\" }, false, [\"encrypt\", \"decrypt\"]);\n            const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n            const ivBytes = encrypted.slice(0, 12);\n            const authTagBytes = encrypted.slice(12, 28);\n            const encryptedPlaintextBytes = encrypted.slice(28);\n            const concattedBytes = new Uint8Array([\n                ...encryptedPlaintextBytes,\n                ...authTagBytes,\n            ]);\n            const algo = {\n                name: \"AES-GCM\",\n                iv: new Uint8Array(ivBytes),\n            };\n            try {\n                const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n                const decoder = new TextDecoder();\n                subscriber.next(decoder.decode(decrypted));\n                subscriber.complete();\n            }\n            catch (err) {\n                subscriber.error(err);\n            }\n        })();\n    });\n}\nexports.decrypt = decrypt;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
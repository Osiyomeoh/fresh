{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeRandomSource = void 0;\n\nconst wipe_1 = require(\"@stablelib/wipe\");\n\nclass NodeRandomSource {\n  constructor() {\n    this.isAvailable = false;\n    this.isInstantiated = false;\n\n    if (typeof require !== \"undefined\") {\n      const nodeCrypto = require(\"crypto\");\n\n      if (nodeCrypto && nodeCrypto.randomBytes) {\n        this._crypto = nodeCrypto;\n        this.isAvailable = true;\n        this.isInstantiated = true;\n      }\n    }\n  }\n\n  randomBytes(length) {\n    if (!this.isAvailable || !this._crypto) {\n      throw new Error(\"Node.js random byte generator is not available.\");\n    } // Get random bytes (result is Buffer).\n\n\n    let buffer = this._crypto.randomBytes(length); // Make sure we got the length that we requested.\n\n\n    if (buffer.length !== length) {\n      throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n    } // Allocate output array.\n\n\n    const out = new Uint8Array(length); // Copy bytes from buffer to output.\n\n    for (let i = 0; i < out.length; i++) {\n      out[i] = buffer[i];\n    } // Cleanup.\n\n\n    (0, wipe_1.wipe)(buffer);\n    return out;\n  }\n\n}\n\nexports.NodeRandomSource = NodeRandomSource;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;AAGA;;AAIA,MAAaA,gBAAb,CAA6B;EAMzBC;IALA,mBAAc,KAAd;IACA,sBAAiB,KAAjB;;IAKI,IAAI,OAAOC,OAAP,KAAmB,WAAvB,EAAoC;MAChC,MAAMC,UAAU,GAAGD,OAAO,CAAC,QAAD,CAA1B;;MACA,IAAIC,UAAU,IAAIA,UAAU,CAACC,WAA7B,EAA0C;QACtC,KAAKC,OAAL,GAAeF,UAAf;QACA,KAAKG,WAAL,GAAmB,IAAnB;QACA,KAAKC,cAAL,GAAsB,IAAtB;MACH;IACJ;EACJ;;EAEDH,WAAW,CAACI,MAAD,EAAe;IACtB,IAAI,CAAC,KAAKF,WAAN,IAAqB,CAAC,KAAKD,OAA/B,EAAwC;MACpC,MAAM,IAAII,KAAJ,CAAU,iDAAV,CAAN;IACH,CAHqB,CAKtB;;;IACA,IAAIC,MAAM,GAAG,KAAKL,OAAL,CAAaD,WAAb,CAAyBI,MAAzB,CAAb,CANsB,CAQtB;;;IACA,IAAIE,MAAM,CAACF,MAAP,KAAkBA,MAAtB,EAA8B;MAC1B,MAAM,IAAIC,KAAJ,CAAU,kDAAV,CAAN;IACH,CAXqB,CAatB;;;IACA,MAAME,GAAG,GAAG,IAAIC,UAAJ,CAAeJ,MAAf,CAAZ,CAdsB,CAgBtB;;IACA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACH,MAAxB,EAAgCK,CAAC,EAAjC,EAAqC;MACjCF,GAAG,CAACE,CAAD,CAAH,GAASH,MAAM,CAACG,CAAD,CAAf;IACH,CAnBqB,CAqBtB;;;IACA,iBAAKH,MAAL;IAEA,OAAOC,GAAP;EACH;;AA1CwB;;AAA7BG","names":["NodeRandomSource","constructor","require","nodeCrypto","randomBytes","_crypto","isAvailable","isInstantiated","length","Error","buffer","out","Uint8Array","i","exports"],"sources":["C:\\Users\\USER\\Documents\\demo-react\\node_modules\\@stablelib\\random\\source\\node.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nimport { RandomSource } from \"./\";\nimport { wipe } from \"@stablelib/wipe\";\n\ndeclare function require(name: string): any;\n\nexport class NodeRandomSource implements RandomSource {\n    isAvailable = false;\n    isInstantiated = false;\n\n    private _crypto: { randomBytes(n: number): Uint8Array } | undefined;\n\n    constructor() {\n        if (typeof require !== \"undefined\") {\n            const nodeCrypto = require(\"crypto\");\n            if (nodeCrypto && nodeCrypto.randomBytes) {\n                this._crypto = nodeCrypto;\n                this.isAvailable = true;\n                this.isInstantiated = true;\n            }\n        }\n    }\n\n    randomBytes(length: number): Uint8Array {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Node.js random byte generator is not available.\");\n        }\n\n        // Get random bytes (result is Buffer).\n        let buffer = this._crypto.randomBytes(length);\n\n        // Make sure we got the length that we requested.\n        if (buffer.length !== length) {\n            throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n        }\n\n        // Allocate output array.\n        const out = new Uint8Array(length);\n\n        // Copy bytes from buffer to output.\n        for (let i = 0; i < out.length; i++) {\n            out[i] = buffer[i];\n        }\n\n        // Cleanup.\n        wipe(buffer);\n\n        return out;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}
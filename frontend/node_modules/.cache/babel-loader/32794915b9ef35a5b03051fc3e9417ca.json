{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package hmac implements HMAC algorithm.\n */\n\nvar hash_1 = require(\"@stablelib/hash\");\n\nvar constant_time_1 = require(\"@stablelib/constant-time\");\n\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\n\n\nvar HMAC =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new HMAC with the given Hash and secret key.\n   */\n  function HMAC(hash, key) {\n    this._finished = false; // true if HMAC was finalized\n    // Initialize inner and outer hashes.\n\n    this._inner = new hash();\n    this._outer = new hash(); // Set block and digest sizes for this HMAC\n    // instance to values from the hash.\n\n    this.blockSize = this._outer.blockSize;\n    this.digestLength = this._outer.digestLength; // Pad temporary stores a key (or its hash) padded with zeroes.\n\n    var pad = new Uint8Array(this.blockSize);\n\n    if (key.length > this.blockSize) {\n      // If key is bigger than hash block size, it must be\n      // hashed and this hash is used as a key instead.\n      this._inner.update(key).finish(pad).clean();\n    } else {\n      // Otherwise, copy the key into pad.\n      pad.set(key);\n    } // Now two different keys are derived from padded key\n    // by xoring a different byte value to each.\n    // To make inner hash key, xor byte 0x36 into pad.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36;\n    } // Update inner hash with the result.\n\n\n    this._inner.update(pad); // To make outer hash key, xor byte 0x5c into pad.\n    // But since we already xored 0x36 there, we must\n    // first undo this by xoring it again.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36 ^ 0x5c;\n    } // Update outer hash with the result.\n\n\n    this._outer.update(pad); // Save states of both hashes, so that we can quickly restore\n    // them later in reset() without the need to remember the actual\n    // key and perform this initialization again.\n\n\n    if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n      this._innerKeyedState = this._inner.saveState();\n      this._outerKeyedState = this._outer.saveState();\n    } // Clean pad.\n\n\n    wipe_1.wipe(pad);\n  }\n  /**\n   * Returns HMAC state to the state initialized with key\n   * to make it possible to run HMAC over the other data with the same\n   * key without creating a new instance.\n   */\n\n\n  HMAC.prototype.reset = function () {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n    } // Restore keyed states of inner and outer hashes.\n\n\n    this._inner.restoreState(this._innerKeyedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n  /**\n   * Cleans HMAC state.\n   */\n\n\n  HMAC.prototype.clean = function () {\n    if (hash_1.isSerializableHash(this._inner)) {\n      this._inner.cleanSavedState(this._innerKeyedState);\n    }\n\n    if (hash_1.isSerializableHash(this._outer)) {\n      this._outer.cleanSavedState(this._outerKeyedState);\n    }\n\n    this._inner.clean();\n\n    this._outer.clean();\n  };\n  /**\n   * Updates state with provided data.\n   */\n\n\n  HMAC.prototype.update = function (data) {\n    this._inner.update(data);\n\n    return this;\n  };\n  /**\n   * Finalizes HMAC and puts the result in out.\n   */\n\n\n  HMAC.prototype.finish = function (out) {\n    if (this._finished) {\n      // If HMAC was finalized, outer hash is also finalized,\n      // so it produces the same digest it produced when it\n      // was finalized.\n      this._outer.finish(out);\n\n      return this;\n    } // Finalize inner hash and store the result temporarily.\n\n\n    this._inner.finish(out); // Update outer hash with digest of inner hash and and finalize it.\n\n\n    this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n\n    this._finished = true;\n    return this;\n  };\n  /**\n   * Returns the computed message authentication code.\n   */\n\n\n  HMAC.prototype.digest = function () {\n    var out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  };\n  /**\n   * Saves HMAC state.\n   * This function is needed for PBKDF2 optimization.\n   */\n\n\n  HMAC.prototype.saveState = function () {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n    }\n\n    return this._inner.saveState();\n  };\n\n  HMAC.prototype.restoreState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n    }\n\n    this._inner.restoreState(savedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n\n  HMAC.prototype.cleanSavedState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n    }\n\n    this._inner.cleanSavedState(savedState);\n  };\n\n  return HMAC;\n}();\n\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\n\nfunction hmac(hash, key, data) {\n  var h = new HMAC(hash, key);\n  h.update(data);\n  var digest = h.digest();\n  h.clean();\n  return digest;\n}\n\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\n\nexports.equal = constant_time_1.equal;","map":{"version":3,"mappings":"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","names":["hash","key","_inner","_outer","blockSize","digestLength","pad","Uint8Array","length","update","finish","clean","set","i","hash_1","_innerKeyedState","saveState","_outerKeyedState","wipe_1","HMAC","Error","restoreState","_finished","cleanSavedState","data","out","subarray","savedState","exports","hmac","h","digest","constant_time_1"],"sources":["C:\\Users\\USER\\Documents\\demo-react\\node_modules\\@stablelib\\hmac\\hmac.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package hmac implements HMAC algorithm.\n */\n\nimport { Hash, SerializableHash, isSerializableHash } from \"@stablelib/hash\";\nimport { equal as constantTimeEqual } from \"@stablelib/constant-time\";\nimport { wipe } from \"@stablelib/wipe\";\n\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nexport class HMAC implements SerializableHash {\n    readonly blockSize: number;\n    readonly digestLength: number;\n\n    private _inner: Hash; // inner hash\n    private _outer: Hash; // outer hash\n\n    private _finished = false; // true if HMAC was finalized\n\n    // Copies of hash states after keying.\n    // Need for quick reset without hashing the key again.\n    private _innerKeyedState: any | undefined;\n    private _outerKeyedState: any | undefined;\n\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */\n    constructor(hash: new () => Hash | SerializableHash, key: Uint8Array) {\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        const pad = new Uint8Array(this.blockSize);\n\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        } else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n\n        // To make inner hash key, xor byte 0x36 into pad.\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (isSerializableHash(this._inner) && isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n\n        // Clean pad.\n        wipe(pad);\n    }\n\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */\n    reset(): this {\n        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    }\n\n    /**\n     * Cleans HMAC state.\n     */\n    clean() {\n        if (isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    }\n\n    /**\n     * Updates state with provided data.\n     */\n    update(data: Uint8Array): this {\n        this._inner.update(data);\n        return this;\n    }\n\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */\n    finish(out: Uint8Array): this {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n\n        return this;\n    }\n\n    /**\n     * Returns the computed message authentication code.\n     */\n    digest(): Uint8Array {\n        const out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    }\n\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */\n    saveState(): any {\n        if (!isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    }\n\n    restoreState(savedState: any): this {\n        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    }\n\n    cleanSavedState(savedState: any) {\n        if (!isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    }\n}\n\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nexport function hmac(hash: new () => Hash, key: Uint8Array, data: Uint8Array): Uint8Array {\n    const h = new HMAC(hash, key);\n    h.update(data);\n    const digest = h.digest();\n    h.clean();\n    return digest;\n}\n\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexport const equal = constantTimeEqual;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\n\nvar int_1 = require(\"@stablelib/int\"); // TODO(dchest): add asserts for correct value ranges and array offsets.\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\n\n\nfunction readInt16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;\n}\n\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\n\nfunction readUint16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;\n}\n\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\n\nfunction readInt16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;\n}\n\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\n\nfunction readUint16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 1] << 8 | array[offset]) >>> 0;\n}\n\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint16BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 8;\n  out[offset + 1] = value >>> 0;\n  return out;\n}\n\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint16LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  return out;\n}\n\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\n\nfunction readInt32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];\n}\n\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\n\nfunction readUint32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;\n}\n\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\n\nfunction readInt32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];\n}\n\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\n\nfunction readUint32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;\n}\n\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 24;\n  out[offset + 1] = value >>> 16;\n  out[offset + 2] = value >>> 8;\n  out[offset + 3] = value >>> 0;\n  return out;\n}\n\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  out[offset + 2] = value >>> 16;\n  out[offset + 3] = value >>> 24;\n  return out;\n}\n\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\n\nfunction readInt64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var hi = readInt32BE(array, offset);\n  var lo = readInt32BE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\n\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\n\nfunction readUint64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var hi = readUint32BE(array, offset);\n  var lo = readUint32BE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\n\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\n\nfunction readInt64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var lo = readInt32LE(array, offset);\n  var hi = readInt32LE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\n\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\n\nfunction readUint64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var lo = readUint32LE(array, offset);\n  var hi = readUint32LE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\n\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n  writeUint32BE(value >>> 0, out, offset + 4);\n  return out;\n}\n\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  writeUint32LE(value >>> 0, out, offset);\n  writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n  return out;\n}\n\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\n\nfunction readUintBE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  }\n\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  }\n\n  var result = 0;\n  var mul = 1;\n\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n\n  return result;\n}\n\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\n\nfunction readUintLE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  }\n\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  }\n\n  var result = 0;\n  var mul = 1;\n\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n\n  return result;\n}\n\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUintBE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  }\n\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintBE value must be an integer\");\n  }\n\n  var div = 1;\n\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n\n  return out;\n}\n\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUintLE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  }\n\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintLE value must be an integer\");\n  }\n\n  var div = 1;\n\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n\n  return out;\n}\n\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\n\nfunction readFloat32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset);\n}\n\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\n\nfunction readFloat32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset, true);\n}\n\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\n\nfunction readFloat64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset);\n}\n\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\n\nfunction readFloat64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset, true);\n}\n\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value);\n  return out;\n}\n\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value, true);\n  return out;\n}\n\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value);\n  return out;\n}\n\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value, true);\n  return out;\n}\n\nexports.writeFloat64LE = writeFloat64LE;","map":{"version":3,"mappings":"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","names":["readInt16BE","array","offset","exports","readUint16BE","readInt16LE","readUint16LE","writeUint16BE","value","out","Uint8Array","writeUint16LE","readInt32BE","readUint32BE","readInt32LE","readUint32LE","writeUint32BE","writeUint32LE","readInt64BE","hi","lo","readUint64BE","readInt64LE","readUint64LE","writeUint64BE","writeUint64LE","readUintBE","bitLength","Error","length","result","mul","i","readUintLE","writeUintBE","int_1","div","writeUintLE","readFloat32BE","view","DataView","buffer","byteOffset","byteLength","getFloat32","readFloat32LE","readFloat64BE","getFloat64","readFloat64LE","writeFloat32BE","setFloat32","writeFloat32LE","writeFloat64BE","setFloat64","writeFloat64LE"],"sources":["C:\\Users\\USER\\Documents\\demo-react\\node_modules\\@stablelib\\binary\\binary.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\n\nimport { isSafeInteger } from \"@stablelib/int\";\n\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nexport function readInt16BE(array: Uint8Array, offset = 0): number {\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nexport function readUint16BE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nexport function readInt16LE(array: Uint8Array, offset = 0): number {\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nexport function readUint16LE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\n\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint16BE(value: number, out = new Uint8Array(2), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\n\nexport const writeInt16BE = writeUint16BE;\n\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint16LE(value: number, out = new Uint8Array(2), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\n\nexport const writeInt16LE = writeUint16LE;\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nexport function readInt32BE(array: Uint8Array, offset = 0): number {\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nexport function readUint32BE(array: Uint8Array, offset = 0): number {\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nexport function readInt32LE(array: Uint8Array, offset = 0): number {\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nexport function readUint32LE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\n\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint32BE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\n\nexport const writeInt32BE = writeUint32BE;\n\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint32LE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\n\n\nexport const writeInt32LE = writeUint32LE;\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport function readInt64BE(array: Uint8Array, offset = 0): number {\n    const hi = readInt32BE(array, offset);\n    const lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo>>31) * 0x100000000);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport function readUint64BE(array: Uint8Array, offset = 0): number {\n    const hi = readUint32BE(array, offset);\n    const lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport function readInt64LE(array: Uint8Array, offset = 0): number {\n    const lo = readInt32LE(array, offset);\n    const hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo>>31) * 0x100000000);\n}\n\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport function readUint64LE(array: Uint8Array, offset = 0): number {\n    const lo = readUint32LE(array, offset);\n    const hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\n\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint64BE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\n\nexport const writeInt64BE = writeUint64BE;\n\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint64LE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\n\nexport const writeInt64LE = writeUint64LE;\n\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport function readUintBE(bitLength: number, array: Uint8Array, offset = 0): number {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    let result = 0;\n    let mul = 1;\n    for (let i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\n\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport function readUintLE(bitLength: number, array: Uint8Array, offset = 0): number {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    let result = 0;\n    let mul = 1;\n    for (let i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\n\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport function writeUintBE(bitLength: number, value: number,\n    out = new Uint8Array(bitLength / 8), offset = 0): Uint8Array {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    let div = 1;\n    for (let i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\n\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport function writeUintLE(bitLength: number, value: number,\n    out = new Uint8Array(bitLength / 8), offset = 0): Uint8Array {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    let div = 1;\n    for (let i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nexport function readFloat32BE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nexport function readFloat32LE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nexport function readFloat64BE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nexport function readFloat64LE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\n\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat32BE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\n\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat32LE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\n\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat64BE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\n\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat64LE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\n"]},"metadata":{},"sourceType":"script"}
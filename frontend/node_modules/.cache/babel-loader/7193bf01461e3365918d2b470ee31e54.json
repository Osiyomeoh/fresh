{"ast":null,"code":"import m from \"pino\";\nimport f from \"@walletconnect/sign-client\";\nimport { getSdkError as g, isValidArray as P } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions as w } from \"@walletconnect/logger\";\nimport { JsonRpcProvider as a } from \"@walletconnect/jsonrpc-provider\";\nimport c, { HttpConnection as C } from \"@walletconnect/jsonrpc-http-connection\";\nimport I from \"events\";\n\nfunction y(i) {\n  var t;\n  const e = (t = i[Object.keys(i)[0]]) == null ? void 0 : t.chains[0];\n  return [e.split(\":\")[0], e.split(\":\")[1]];\n}\n\nfunction r(i, t) {\n  let e;\n  return t.rpcMap && (e = t.rpcMap[O([i])]), e;\n}\n\nfunction O(i) {\n  return Number(i[0].split(\":\")[1]);\n}\n\nclass E {\n  constructor(t) {\n    this.name = \"eip155\", this.namespace = t.namespace, this.client = t.client, this.events = t.events, this.httpProviders = this.createHttpProviders(), this.chainId = this.getDefaultChainId();\n  }\n\n  async request(t) {\n    var e;\n\n    switch (t.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n\n      case \"eth_accounts\":\n        return this.getAccounts();\n\n      case \"wallet_switchEthereumChain\":\n        {\n          const s = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : \"0x0\";\n          return this.setDefaultChain(parseInt(s, 16).toString()), null;\n        }\n\n      case \"eth_chainId\":\n        return this.getDefaultChainId();\n    }\n\n    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  setDefaultChain(t, e) {\n    if (this.chainId = parseInt(t), !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new C(s));\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return parseInt(t.split(\":\")[1]);\n  }\n\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n}\n\nclass q {\n  constructor(t) {\n    this.name = \"solana\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new c(s));\n  }\n\n}\n\nclass H {\n  constructor(t) {\n    this.name = \"cosmos\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new c(s));\n  }\n\n}\n\nclass $ {\n  constructor(t) {\n    this.name = \"cip34\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new c(s));\n  }\n\n}\n\nconst h = \"error\",\n      b = \"wss://relay.walletconnect.com\",\n      S = \"wc\",\n      A = \"universal_provider\",\n      p = `${S}@${2}:${A}:`;\n\nvar N = Object.defineProperty,\n    D = Object.defineProperties,\n    j = Object.getOwnPropertyDescriptors,\n    d = Object.getOwnPropertySymbols,\n    k = Object.prototype.hasOwnProperty,\n    R = Object.prototype.propertyIsEnumerable,\n    l = (i, t, e) => t in i ? N(i, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: e\n}) : i[t] = e,\n    u = (i, t) => {\n  for (var e in t || (t = {})) k.call(t, e) && l(i, e, t[e]);\n\n  if (d) for (var e of d(t)) R.call(t, e) && l(i, e, t[e]);\n  return i;\n},\n    _ = (i, t) => D(i, j(t));\n\nclass o {\n  constructor(t) {\n    this.events = new I(), this.rpcProviders = {}, this.providerOpts = t, this.logger = typeof t?.logger < \"u\" && typeof t?.logger != \"string\" ? t.logger : m(w({\n      level: t?.logger || h\n    }));\n  }\n\n  static async init(t) {\n    const e = new o(t);\n    return await e.initialize(), e;\n  }\n\n  async request(t, e) {\n    const [s, n] = this.validateChain(e);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(s).request({\n      request: u({}, t),\n      chainId: `${s}:${n}`,\n      topic: this.session.topic\n    });\n  }\n\n  sendAsync(t, e, s) {\n    this.request(t, s).then(n => e(null, n)).catch(n => e(n, void 0));\n  }\n\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces\n    })), await this.requestAccounts();\n  }\n\n  async disconnect() {\n    var t;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (t = this.session) == null ? void 0 : t.topic,\n      reason: g(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n\n  async connect(t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    const {\n      namespaces: e\n    } = t;\n    return this.setNamespaces(e), this.createProviders(), await this.cleanupPendingPairings(), t.skipPairing === !0 ? void 0 : await this.pair(t.pairingTopic);\n  }\n\n  on(t, e) {\n    this.events.on(t, e);\n  }\n\n  once(t, e) {\n    this.events.once(t, e);\n  }\n\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n\n  off(t, e) {\n    this.events.off(t, e);\n  }\n\n  get isWalletConnect() {\n    return !0;\n  }\n\n  async pair(t) {\n    const {\n      uri: e,\n      approval: s\n    } = await this.client.connect({\n      pairingTopic: t,\n      requiredNamespaces: this.namespaces\n    });\n    return e && (this.uri = e, this.events.emit(\"display_uri\", e)), this.session = await s(), this.onSessionUpdate(), this.onConnect(), this.session;\n  }\n\n  setDefaultChain(t, e) {\n    try {\n      const [s, n] = this.validateChain(t);\n      this.getProvider(s).setDefaultChain(n, e);\n    } catch (s) {\n      if (!/Please call connect/.test(s.message)) throw s;\n    }\n  }\n\n  async cleanupPendingPairings() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const e = this.client.pairing.getAll();\n\n    if (P(e)) {\n      for (const s of e) t.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);\n\n      this.logger.info(`Inactive pairings cleared: ${e.length}`);\n    }\n  }\n\n  async checkStorage() {\n    if (this.namespaces = (await this.client.core.storage.getItem(`${p}/namespaces`)) || {}, this.namespaces && this.createProviders(), this.client.session.length) {\n      const t = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[t]), this.onSessionUpdate();\n    }\n  }\n\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), this.checkStorage(), this.registerEventListeners();\n  }\n\n  async createClient() {\n    this.client = this.providerOpts.client || (await f.init({\n      logger: this.providerOpts.logger || h,\n      relayUrl: this.providerOpts.relayUrl || b,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      name: this.providerOpts.name\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    Object.keys(this.namespaces).forEach(t => {\n      switch (t) {\n        case \"eip155\":\n          this.rpcProviders[t] = new E({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n\n        case \"solana\":\n          this.rpcProviders[t] = new q({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n\n        case \"cosmos\":\n          this.rpcProviders[t] = new H({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n\n        case \"polkadot\":\n          break;\n\n        case \"cip34\":\n          this.rpcProviders[t] = new $({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n      }\n    });\n  }\n\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", t => {\n      this.events.emit(\"session_ping\", t);\n    }), this.client.on(\"session_event\", t => {\n      const {\n        params: e\n      } = t,\n            {\n        event: s\n      } = e;\n      s.name === \"accountsChanged\" ? this.events.emit(\"accountsChanged\", s.data) : s.name === \"chainChanged\" ? this.onChainChanged(s.data, e.chainId) : this.events.emit(s.name, s.data), this.events.emit(\"session_event\", t);\n    }), this.client.on(\"session_update\", _ref => {\n      let {\n        topic: t,\n        params: e\n      } = _ref;\n      var s;\n      const {\n        namespaces: n\n      } = e,\n            v = (s = this.client) == null ? void 0 : s.session.get(t);\n      this.session = _(u({}, v), {\n        namespaces: n\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: t,\n        params: e\n      });\n    }), this.client.on(\"session_delete\", async t => {\n      await this.cleanup(), this.events.emit(\"session_delete\", t);\n    });\n  }\n\n  getProvider(t) {\n    if (!this.rpcProviders[t]) throw new Error(`Provider not found: ${t}`);\n    return this.rpcProviders[t];\n  }\n\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(t => {\n      var e;\n      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);\n    });\n  }\n\n  setNamespaces(t) {\n    if (!t || !Object.keys(t).length) throw new Error(\"Namespaces must be not empty\");\n    this.client.core.storage.setItem(`${p}/namespaces`, t), this.namespaces = t;\n  }\n\n  validateChain(t) {\n    const [e, s] = t?.split(\":\") || [\"\", \"\"];\n    if (e && !Object.keys(this.namespaces).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);\n    return !e || !s ? y(this.namespaces) : [e, s];\n  }\n\n  async requestAccounts() {\n    const [t] = this.validateChain();\n    return await this.getProvider(t).requestAccounts();\n  }\n\n  onChainChanged(t, e) {\n    const [s, n] = this.validateChain(e);\n    this.getProvider(s).setDefaultChain(n), this.events.emit(\"chainChanged\", t);\n  }\n\n  onConnect() {\n    this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n\n  async cleanup() {\n    this.session = void 0, await this.cleanupPendingPairings({\n      deletePairings: !0\n    });\n  }\n\n}\n\nconst U = o;\nexport { U as UniversalProvider, o as default };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import m from\"pino\";import f from\"@walletconnect/sign-client\";import{getSdkError as g,isValidArray as P}from\"@walletconnect/utils\";import{getDefaultLoggerOptions as w}from\"@walletconnect/logger\";import{JsonRpcProvider as a}from\"@walletconnect/jsonrpc-provider\";import c,{HttpConnection as C}from\"@walletconnect/jsonrpc-http-connection\";import I from\"events\";function y(i){var t;const e=(t=i[Object.keys(i)[0]])==null?void 0:t.chains[0];return[e.split(\":\")[0],e.split(\":\")[1]]}function r(i,t){let e;return t.rpcMap&&(e=t.rpcMap[O([i])]),e}function O(i){return Number(i[0].split(\":\")[1])}class E{constructor(t){this.name=\"eip155\",this.namespace=t.namespace,this.client=t.client,this.events=t.events,this.httpProviders=this.createHttpProviders(),this.chainId=this.getDefaultChainId()}async request(t){var e;switch(t.request.method){case\"eth_requestAccounts\":return this.getAccounts();case\"eth_accounts\":return this.getAccounts();case\"wallet_switchEthereumChain\":{const s=t.request.params?(e=t.request.params[0])==null?void 0:e.chainId:\"0x0\";return this.setDefaultChain(parseInt(s,16).toString()),null}case\"eth_chainId\":return this.getDefaultChainId()}return this.namespace.methods.includes(t.request.method)?await this.client.request(t):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){if(this.chainId=parseInt(t),!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(\"chainChanged\",this.chainId)}requestAccounts(){return this.getAccounts()}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>\"u\"?void 0:new a(new C(s))}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2])||[]:[]}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return parseInt(t.split(\":\")[1])}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}}class q{constructor(t){this.name=\"solana\",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(\"chainChanged\",this.chainId)}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>\"u\"?void 0:new a(new c(s))}}class H{constructor(t){this.name=\"cosmos\",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(\"chainChanged\",this.chainId)}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>\"u\"?void 0:new a(new c(s))}}class ${constructor(t){this.name=\"cip34\",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(\"chainChanged\",this.chainId)}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>\"u\"?void 0:new a(new c(s))}}const h=\"error\",b=\"wss://relay.walletconnect.com\",S=\"wc\",A=\"universal_provider\",p=`${S}@${2}:${A}:`;var N=Object.defineProperty,D=Object.defineProperties,j=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,k=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable,l=(i,t,e)=>t in i?N(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,u=(i,t)=>{for(var e in t||(t={}))k.call(t,e)&&l(i,e,t[e]);if(d)for(var e of d(t))R.call(t,e)&&l(i,e,t[e]);return i},_=(i,t)=>D(i,j(t));class o{constructor(t){this.events=new I,this.rpcProviders={},this.providerOpts=t,this.logger=typeof t?.logger<\"u\"&&typeof t?.logger!=\"string\"?t.logger:m(w({level:t?.logger||h}))}static async init(t){const e=new o(t);return await e.initialize(),e}async request(t,e){const[s,n]=this.validateChain(e);if(!this.session)throw new Error(\"Please call connect() before request()\");return await this.getProvider(s).request({request:u({},t),chainId:`${s}:${n}`,topic:this.session.topic})}sendAsync(t,e,s){this.request(t,s).then(n=>e(null,n)).catch(n=>e(n,void 0))}async enable(){if(!this.client)throw new Error(\"Sign Client not initialized\");return this.session||await this.connect({namespaces:this.namespaces}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error(\"Please call connect() before enable()\");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:g(\"USER_DISCONNECTED\")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error(\"Sign Client not initialized\");const{namespaces:e}=t;return this.setNamespaces(e),this.createProviders(),await this.cleanupPendingPairings(),t.skipPairing===!0?void 0:await this.pair(t.pairingTopic)}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){const{uri:e,approval:s}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces});return e&&(this.uri=e,this.events.emit(\"display_uri\",e)),this.session=await s(),this.onSessionUpdate(),this.onConnect(),this.session}setDefaultChain(t,e){try{const[s,n]=this.validateChain(t);this.getProvider(s).setDefaultChain(n,e)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(t={}){this.logger.info(\"Cleaning up inactive pairings...\");const e=this.client.pairing.getAll();if(P(e)){for(const s of e)t.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${e.length}`)}}async checkStorage(){if(this.namespaces=await this.client.core.storage.getItem(`${p}/namespaces`)||{},this.namespaces&&this.createProviders(),this.client.session.length){const t=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[t]),this.onSessionUpdate()}}async initialize(){this.logger.trace(\"Initialized\"),await this.createClient(),this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await f.init({logger:this.providerOpts.logger||h,relayUrl:this.providerOpts.relayUrl||b,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,name:this.providerOpts.name}),this.logger.trace(\"SignClient Initialized\")}createProviders(){if(!this.client)throw new Error(\"Sign Client not initialized\");Object.keys(this.namespaces).forEach(t=>{switch(t){case\"eip155\":this.rpcProviders[t]=new E({client:this.client,namespace:this.namespaces[t],events:this.events});break;case\"solana\":this.rpcProviders[t]=new q({client:this.client,namespace:this.namespaces[t],events:this.events});break;case\"cosmos\":this.rpcProviders[t]=new H({client:this.client,namespace:this.namespaces[t],events:this.events});break;case\"polkadot\":break;case\"cip34\":this.rpcProviders[t]=new $({client:this.client,namespace:this.namespaces[t],events:this.events});break}})}registerEventListeners(){if(typeof this.client>\"u\")throw new Error(\"Sign Client is not initialized\");this.client.on(\"session_ping\",t=>{this.events.emit(\"session_ping\",t)}),this.client.on(\"session_event\",t=>{const{params:e}=t,{event:s}=e;s.name===\"accountsChanged\"?this.events.emit(\"accountsChanged\",s.data):s.name===\"chainChanged\"?this.onChainChanged(s.data,e.chainId):this.events.emit(s.name,s.data),this.events.emit(\"session_event\",t)}),this.client.on(\"session_update\",({topic:t,params:e})=>{var s;const{namespaces:n}=e,v=(s=this.client)==null?void 0:s.session.get(t);this.session=_(u({},v),{namespaces:n}),this.onSessionUpdate(),this.events.emit(\"session_update\",{topic:t,params:e})}),this.client.on(\"session_delete\",async t=>{await this.cleanup(),this.events.emit(\"session_delete\",t)})}getProvider(t){if(!this.rpcProviders[t])throw new Error(`Provider not found: ${t}`);return this.rpcProviders[t]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var e;this.getProvider(t).updateNamespace((e=this.session)==null?void 0:e.namespaces[t])})}setNamespaces(t){if(!t||!Object.keys(t).length)throw new Error(\"Namespaces must be not empty\");this.client.core.storage.setItem(`${p}/namespaces`,t),this.namespaces=t}validateChain(t){const[e,s]=t?.split(\":\")||[\"\",\"\"];if(e&&!Object.keys(this.namespaces).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);return!e||!s?y(this.namespaces):[e,s]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}onChainChanged(t,e){const[s,n]=this.validateChain(e);this.getProvider(s).setDefaultChain(n),this.events.emit(\"chainChanged\",t)}onConnect(){this.events.emit(\"connect\",{session:this.session})}async cleanup(){this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0})}}const U=o;export{U as UniversalProvider,o as default};\n"]},"metadata":{},"sourceType":"module"}
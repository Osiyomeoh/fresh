{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKConnection = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst Session_1 = require(\"../relay/Session\");\n\nconst types_1 = require(\"../types\");\n\nconst ClientMessage_1 = require(\"./ClientMessage\");\n\nconst DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\n\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\n\nconst ServerMessage_1 = require(\"./ServerMessage\");\n\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\n\nclass WalletSDKConnection {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(sessionId, sessionKey, linkAPIUrl, diagnostic) {\n    let WebSocketClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : WebSocket;\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.diagnostic = diagnostic;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, types_1.IntNumber)(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws; // attempt to reconnect every 5 seconds when disconnected\n\n    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)(state => {\n      var _a;\n\n      return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n        state,\n        sessionIdHash: Session_1.Session.hash(sessionId)\n      });\n    }), // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), // if DISCONNECTED and not destroyed\n    (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), // wait 5 seconds\n    (0, operators_1.delay)(5000), // check whether it's destroyed again\n    (0, operators_1.filter)(_ => !this.destroyed), // reconnect\n    (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)()).subscribe()); // perform authentication upon connection\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED and CONNECTING states\n    (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), // if not CONNECTED, emit false immediately\n    (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false))).subscribe(connected => this.connectedSubject.next(connected))); // send heartbeat every n seconds while connected\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, start the heartbeat timer\n    (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)))).subscribe(i => // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat())); // handle server's heartbeat responses\n\n    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat())); // handle link status updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      var _a;\n\n      const msg = m;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        linked: msg.linked,\n        type: m.type,\n        onlineGuests: msg.onlineGuests\n      });\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    })); // handle session config updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      var _a;\n\n      const msg = m;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n      });\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n\n\n  connect() {\n    var _a;\n\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.ws.connect().subscribe();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletSDKConnection\n   */\n\n\n  destroy() {\n    var _a;\n\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.destroyed = true;\n  }\n\n  get isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * Emit true if connected and authenticated, else false\n   * @returns an Observable\n   */\n\n\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\n   * Emit once connected\n   * @returns an Observable\n   */\n\n\n  get onceConnected$() {\n    return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit true if linked (a guest has joined before)\n   * @returns an Observable\n   */\n\n\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\n   * Emit once when linked\n   * @returns an Observable\n   */\n\n\n  get onceLinked$() {\n    return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit current session config if available, and subsequent updates\n   * @returns an Observable for the session config\n   */\n\n\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\n   * Emit incoming Event messages\n   * @returns an Observable for the messages\n   */\n\n\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), (0, operators_1.map)(m => m));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns an Observable that completes when successful\n   */\n\n\n  setSessionMetadata(key, value) {\n    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param data event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns an Observable that emits event ID when successful\n   */\n\n\n  publishEvent(event, data) {\n    let callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n\n      return res.eventId;\n    }));\n  }\n\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n\n  makeRequest(message) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : REQUEST_TIMEOUT;\n    const reqId = message.id;\n\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return (0, rxjs_1.throwError)(err);\n    } // await server message with corresponding id\n\n\n    return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n  }\n\n  authenticate() {\n    const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n\n  sendIsLinked() {\n    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n  sendGetSessionConfig() {\n    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n}\n\nexports.WalletSDKConnection = WalletSDKConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","WalletSDKConnection","rxjs_1","require","operators_1","Session_1","types_1","ClientMessage_1","DiagnosticLogger_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","constructor","sessionId","sessionKey","linkAPIUrl","diagnostic","WebSocketClass","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","tap","state","_a","log","EVENTS","CONNECTED_STATE_CHANGE","sessionIdHash","Session","hash","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","LINKED","linked","onlineGuests","SESSION_CONFIG_RECEIVED","metadata_keys","metadata","keys","undefined","webhookId","webhookUrl","Error","STARTED_CONNECTING","destroy","unsubscribe","disconnect","isDestroyed","connected$","asObservable","onceConnected$","v","take","linked$","onceLinked$","sessionConfig$","incomingEvent$","sme","eventId","event","data","setSessionMetadata","key","message","ClientMessageSetSessionConfig","id","makeRequest","res","isServerMessageFail","error","publishEvent","callWebhook","ClientMessagePublishEvent","sendData","JSON","stringify","Date","now","timeout","reqId","err","throwError","timeoutWith","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"sources":["C:/Users/USER/Documents/demo-react/node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletSDKConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletSDKConnection {\n    /**\n     * Constructor\n     * @param sessionId Session ID\n     * @param sessionKey Session Key\n     * @param linkAPIUrl Coinbase Wallet link server URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {\n        this.sessionId = sessionId;\n        this.sessionKey = sessionKey;\n        this.diagnostic = diagnostic;\n        this.subscriptions = new rxjs_1.Subscription();\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = (0, types_1.IntNumber)(1);\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n        const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n        this.ws = ws;\n        // attempt to reconnect every 5 seconds when disconnected\n        this.subscriptions.add(ws.connectionState$\n            .pipe((0, operators_1.tap)(state => {\n            var _a;\n            return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n                state,\n                sessionIdHash: Session_1.Session.hash(sessionId),\n            });\n        }), \n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), \n        // if DISCONNECTED and not destroyed\n        (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \n        // wait 5 seconds\n        (0, operators_1.delay)(5000), \n        // check whether it's destroyed again\n        (0, operators_1.filter)(_ => !this.destroyed), \n        // reconnect\n        (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)())\n            .subscribe());\n        // perform authentication upon connection\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED and CONNECTING states\n        (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, authenticate, and then check link status\n        this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), \n        // if not CONNECTED, emit false immediately\n        (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false)))\n            .subscribe(connected => this.connectedSubject.next(connected)));\n        // send heartbeat every n seconds while connected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, start the heartbeat timer\n        (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL))))\n            .subscribe(i => \n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n        // handle server's heartbeat responses\n        this.subscriptions.add(ws.incomingData$\n            .pipe((0, operators_1.filter)(m => m === \"h\"))\n            .subscribe(_ => this.updateLastHeartbeat()));\n        // handle link status updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                linked: msg.linked,\n                type: m.type,\n                onlineGuests: msg.onlineGuests,\n            });\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n        }));\n        // handle session config updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined,\n            });\n            this.sessionConfigSubject.next({\n                webhookId: msg.webhookId,\n                webhookUrl: msg.webhookUrl,\n                metadata: msg.metadata,\n            });\n        }));\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        var _a;\n        if (this.destroyed) {\n            throw new Error(\"instance is destroyed\");\n        }\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n    destroy() {\n        var _a;\n        this.subscriptions.unsubscribe();\n        this.ws.disconnect();\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.destroyed = true;\n    }\n    get isDestroyed() {\n        return this.destroyed;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n    get connected$() {\n        return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n    get onceConnected$() {\n        return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n    get linked$() {\n        return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n    get onceLinked$() {\n        return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n    get sessionConfig$() {\n        return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n    get incomingEvent$() {\n        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n            if (m.type !== \"Event\") {\n                return false;\n            }\n            const sme = m;\n            return (typeof sme.sessionId === \"string\" &&\n                typeof sme.eventId === \"string\" &&\n                typeof sme.event === \"string\" &&\n                typeof sme.data === \"string\");\n        }), (0, operators_1.map)(m => m));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n    setSessionMetadata(key, value) {\n        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            metadata: { [key]: value },\n        });\n        return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to set session metadata\");\n            }\n        }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n    publishEvent(event, data, callWebhook = false) {\n        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            event,\n            data,\n            callWebhook,\n        });\n        return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to publish event\");\n            }\n            return res.eventId;\n        }));\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData(\"h\");\n        }\n        catch (_a) { }\n    }\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        try {\n            this.sendData(message);\n        }\n        catch (err) {\n            return (0, rxjs_1.throwError)(err);\n        }\n        // await server message with corresponding id\n        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n    }\n    authenticate() {\n        const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            sessionKey: this.sessionKey,\n        });\n        return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to authentcate\");\n            }\n        }));\n    }\n    sendIsLinked() {\n        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n    sendGetSessionConfig() {\n        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n}\nexports.WalletSDKConnection = WalletSDKConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
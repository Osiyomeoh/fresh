{"ast":null,"code":"import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\nexport class CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n\n  toV0() {\n    switch (this.version) {\n      case 0:\n        {\n          return this;\n        }\n\n      default:\n        {\n          const {\n            code,\n            multihash\n          } = this;\n\n          if (code !== DAG_PB_CODE) {\n            throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n          }\n\n          if (multihash.code !== SHA_256_CODE) {\n            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n          }\n\n          return CID.createV0(multihash);\n        }\n    }\n  }\n\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n            code,\n            digest\n          } = this.multihash;\n          const multihash = Digest.create(code, digest);\n          return CID.createV1(this.code, multihash);\n        }\n\n      case 1:\n        {\n          return this;\n        }\n\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n        }\n    }\n  }\n\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && Digest.equals(this.multihash, other.multihash);\n  }\n\n  toString(base) {\n    const {\n      bytes,\n      version,\n      _baseCache\n    } = this;\n\n    switch (version) {\n      case 0:\n        return toStringV0(bytes, _baseCache, base || base58btc.encoder);\n\n      default:\n        return toStringV1(bytes, _baseCache, base || base32.encoder);\n    }\n  }\n\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {\n        version,\n        code,\n        multihash,\n        bytes\n      } = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {\n        version,\n        multihash,\n        code\n      } = value;\n      const digest = Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      return null;\n    }\n  }\n\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n\n    switch (version) {\n      case 0:\n        {\n          if (code !== DAG_PB_CODE) {\n            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n          } else {\n            return new CID(version, code, digest, digest.bytes);\n          }\n        }\n\n      case 1:\n        {\n          const bytes = encodeCID(version, code, digest.bytes);\n          return new CID(version, code, digest, bytes);\n        }\n\n      default:\n        {\n          throw new Error('Invalid version');\n        }\n    }\n  }\n\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n\n    return cid;\n  }\n\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [cid, bytes.subarray(specs.size)];\n  }\n\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n\n    let version = next();\n    let codec = DAG_PB_CODE;\n\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`);\n    }\n\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n\n    cid._baseCache.set(prefix, source);\n\n    return cid;\n  }\n\n}\n\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    case 'Q':\n      {\n        const decoder = base || base58btc;\n        return [base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)];\n      }\n\n    case base58btc.prefix:\n      {\n        const decoder = base || base58btc;\n        return [base58btc.prefix, decoder.decode(source)];\n      }\n\n    case base32.prefix:\n      {\n        const decoder = base || base32;\n        return [base32.prefix, decoder.decode(source)];\n      }\n\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n\n        return [source[0], base.decode(source)];\n      }\n  }\n};\n\nconst toStringV0 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n  }\n\n  const cid = cache.get(prefix);\n\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n\nconst toStringV1 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  const cid = cache.get(prefix);\n\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\n\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\n\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\n\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;","map":{"version":3,"names":["varint","Digest","base58btc","base32","coerce","CID","constructor","version","code","multihash","bytes","byteOffset","byteLength","asCID","_baseCache","Map","Object","defineProperties","hidden","readonly","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","toV1","digest","create","createV1","equals","other","toString","base","toStringV0","encoder","toStringV1","toJSON","hash","Symbol","toStringTag","for","isCID","value","deprecate","IS_CID_DEPRECATION","cidSymbol","toBaseEncodedString","codec","buffer","multibaseName","prefix","encodeCID","decode","cid","remainder","decodeFirst","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","initialBytes","offset","next","i","RangeError","parse","source","parseCIDtoBytes","set","decoder","cache","name","get","encode","slice","codeOffset","encodingLength","hashOffset","Uint8Array","encodeTo","writable","configurable","enumerable","range","message","test","console","warn"],"sources":["C:/Users/USER/Documents/demo-react/node_modules/multiformats/esm/src/cid.js"],"sourcesContent":["import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\nexport class CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n    case 0: {\n        return this;\n      }\n    default: {\n        const {code, multihash} = this;\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n    case 0: {\n        const {code, digest} = this.multihash;\n        const multihash = Digest.create(code, digest);\n        return CID.createV1(this.code, multihash);\n      }\n    case 1: {\n        return this;\n      }\n    default: {\n        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && Digest.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {bytes, version, _baseCache} = this;\n    switch (version) {\n    case 0:\n      return toStringV0(bytes, _baseCache, base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, _baseCache, base || base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {version, code, multihash, bytes} = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {version, multihash, code} = value;\n      const digest = Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n    case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);\n        } else {\n          return new CID(version, code, digest, digest.bytes);\n        }\n      }\n    case 1: {\n        const bytes = encodeCID(version, code, digest.bytes);\n        return new CID(version, code, digest, bytes);\n      }\n    default: {\n        throw new Error('Invalid version');\n      }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [\n      cid,\n      bytes.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${ version }`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n  case 'Q': {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(`${ base58btc.prefix }${ source }`)\n      ];\n    }\n  case base58btc.prefix: {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(source)\n      ];\n    }\n  case base32.prefix: {\n      const decoder = base || base32;\n      return [\n        base32.prefix,\n        decoder.decode(source)\n      ];\n    }\n  default: {\n      if (base == null) {\n        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n      }\n      return [\n        source[0],\n        base.decode(source)\n      ];\n    }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {prefix} = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {prefix} = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"const EthQuery = require('eth-query');\n\nconst pify = require('pify');\n\nconst BaseFilterWithHistory = require('./base-filter-history');\n\nconst {\n  bnToHex,\n  hexToInt,\n  incrementHexInt,\n  minBlockRef,\n  blockRefIsNumber\n} = require('./hexUtils');\n\nclass LogFilter extends BaseFilterWithHistory {\n  constructor(_ref) {\n    let {\n      provider,\n      params\n    } = _ref;\n    super();\n    this.type = 'log';\n    this.ethQuery = new EthQuery(provider);\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: []\n    }, params); // normalize address parameter\n\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address];\n      } // ensure lowercase\n\n\n      this.params.address = this.params.address.map(address => address.toLowerCase());\n    }\n  }\n\n  async initialize(_ref2) {\n    let {\n      currentBlock\n    } = _ref2;\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock;\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;\n    if ('earliest' === fromBlock) fromBlock = '0x0';\n    this.params.fromBlock = fromBlock; // set toBlock for initial lookup\n\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock);\n    const params = Object.assign({}, this.params, {\n      toBlock\n    }); // fetch logs and add to results\n\n    const newLogs = await this._fetchLogs(params);\n    this.addInitialResults(newLogs);\n  }\n\n  async update(_ref3) {\n    let {\n      oldBlock,\n      newBlock\n    } = _ref3;\n    // configure params for this update\n    const toBlock = newBlock;\n    let fromBlock; // oldBlock is empty on first sync\n\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock);\n    } else {\n      fromBlock = newBlock;\n    } // fetch logs\n\n\n    const params = Object.assign({}, this.params, {\n      fromBlock,\n      toBlock\n    });\n    const newLogs = await this._fetchLogs(params);\n    const matchingLogs = newLogs.filter(log => this.matchLog(log)); // add to results\n\n    this.addResults(matchingLogs);\n  }\n\n  async _fetchLogs(params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))(); // add to results\n\n    return newLogs;\n  }\n\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false;\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false; // address is correct:\n\n    const normalizedLogAddress = log.address && log.address.toLowerCase();\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false; // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index];\n      if (!logTopic) return false;\n      logTopic = logTopic.toLowerCase(); // normalize subTopics\n\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]; // check for wild card\n\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);\n      if (subtopicsIncludeWildcard) return true;\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase()); // check each possible matching topic\n\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic);\n      return topicDoesMatch;\n    });\n    return topicsMatch;\n  }\n\n}\n\nmodule.exports = LogFilter;","map":{"version":3,"names":["EthQuery","require","pify","BaseFilterWithHistory","bnToHex","hexToInt","incrementHexInt","minBlockRef","blockRefIsNumber","LogFilter","constructor","provider","params","type","ethQuery","Object","assign","fromBlock","toBlock","address","undefined","topics","Array","isArray","map","toLowerCase","initialize","currentBlock","includes","newLogs","_fetchLogs","addInitialResults","update","oldBlock","newBlock","matchingLogs","filter","log","matchLog","addResults","cb","getLogs","blockNumber","normalizedLogAddress","topicsMatch","every","topicPattern","index","logTopic","subtopicsToMatch","subtopicsIncludeWildcard","topic","topicDoesMatch","module","exports"],"sources":["C:/Users/USER/Documents/demo-react/node_modules/eth-json-rpc-filters/log-filter.js"],"sourcesContent":["const EthQuery = require('eth-query')\nconst pify = require('pify')\nconst BaseFilterWithHistory = require('./base-filter-history')\nconst { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require('./hexUtils')\n\nclass LogFilter extends BaseFilterWithHistory {\n\n  constructor ({ provider, params }) {\n    super()\n    this.type = 'log'\n    this.ethQuery = new EthQuery(provider)\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: [],\n    }, params)\n    // normalize address parameter\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address]\n      }\n      // ensure lowercase\n      this.params.address = this.params.address.map(address => address.toLowerCase())\n    }\n  }\n\n  async initialize({ currentBlock }) {\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock\n    if ('earliest' === fromBlock) fromBlock = '0x0'\n    this.params.fromBlock = fromBlock\n    // set toBlock for initial lookup\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock)\n    const params = Object.assign({}, this.params, { toBlock })\n    // fetch logs and add to results\n    const newLogs = await this._fetchLogs(params)\n    this.addInitialResults(newLogs)\n  }\n\n  async update ({ oldBlock, newBlock }) {\n    // configure params for this update\n    const toBlock = newBlock\n    let fromBlock\n    // oldBlock is empty on first sync\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock)\n    } else {\n      fromBlock = newBlock\n    }\n    // fetch logs\n    const params = Object.assign({}, this.params, { fromBlock, toBlock })\n    const newLogs = await this._fetchLogs(params)\n    const matchingLogs = newLogs.filter(log => this.matchLog(log))\n\n    // add to results\n    this.addResults(matchingLogs)\n  }\n\n  async _fetchLogs (params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))()\n    // add to results\n    return newLogs\n  }\n\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false\n\n    // address is correct:\n    const normalizedLogAddress = log.address && log.address.toLowerCase()\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false\n\n    // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index]\n      if (!logTopic) return false\n      logTopic = logTopic.toLowerCase()\n      // normalize subTopics\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]\n      // check for wild card\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null)\n      if (subtopicsIncludeWildcard) return true\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase())\n      // check each possible matching topic\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic)\n      return topicDoesMatch\n    })\n\n    return topicsMatch\n  }\n\n}\n\nmodule.exports = LogFilter\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
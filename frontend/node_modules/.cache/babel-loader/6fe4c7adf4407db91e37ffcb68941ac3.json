{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;\n\nconst system_1 = require(\"./source/system\");\n\nconst binary_1 = require(\"@stablelib/binary\");\n\nconst wipe_1 = require(\"@stablelib/wipe\");\n\nexports.defaultRandomSource = new system_1.SystemRandomSource();\n\nfunction randomBytes(length) {\n  let prng = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.defaultRandomSource;\n  return prng.randomBytes(length);\n}\n\nexports.randomBytes = randomBytes;\n/**\n * Returns a uniformly random unsigned 32-bit integer.\n */\n\nfunction randomUint32() {\n  let prng = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.defaultRandomSource;\n  // Generate 4-byte random buffer.\n  const buf = randomBytes(4, prng); // Convert bytes from buffer into a 32-bit integer.\n  // It's not important which byte order to use, since\n  // the result is random.\n\n  const result = (0, binary_1.readUint32LE)(buf); // Clean the buffer.\n\n  (0, wipe_1.wipe)(buf);\n  return result;\n}\n\nexports.randomUint32 = randomUint32;\n/** 62 alphanumeric characters for default charset of randomString() */\n\nconst ALPHANUMERIC = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n/**\n * Returns a uniform random string of the given length\n * with characters from the given charset.\n *\n * Charset must not have more than 256 characters.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\n\nfunction randomString(length) {\n  let charset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALPHANUMERIC;\n  let prng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.defaultRandomSource;\n\n  if (charset.length < 2) {\n    throw new Error(\"randomString charset is too short\");\n  }\n\n  if (charset.length > 256) {\n    throw new Error(\"randomString charset is too long\");\n  }\n\n  let out = '';\n  const charsLen = charset.length;\n  const maxByte = 256 - 256 % charsLen;\n\n  while (length > 0) {\n    const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);\n\n    for (let i = 0; i < buf.length && length > 0; i++) {\n      const randomByte = buf[i];\n\n      if (randomByte < maxByte) {\n        out += charset.charAt(randomByte % charsLen);\n        length--;\n      }\n    }\n\n    (0, wipe_1.wipe)(buf);\n  }\n\n  return out;\n}\n\nexports.randomString = randomString;\n/**\n * Returns uniform random string containing at least the given\n * number of bits of entropy.\n *\n * For example, randomStringForEntropy(128) will return a 22-character\n * alphanumeric string, while randomStringForEntropy(128, \"0123456789\")\n * will return a 39-character numeric string, both will contain at\n * least 128 bits of entropy.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\n\nfunction randomStringForEntropy(bits) {\n  let charset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALPHANUMERIC;\n  let prng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.defaultRandomSource;\n  const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));\n  return randomString(length, charset, prng);\n}\n\nexports.randomStringForEntropy = randomStringForEntropy;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;AAQA;;AACA;;AACA;;AAIaA,8BAAsB,IAAIC,2BAAJ,EAAtB;;AAEb,SAAgBC,WAAhB,CAA4BC,MAA5B,EAAoF;EAAA,IAAxCC,IAAwC,uEAAnBJ,2BAAmB;EAChF,OAAOI,IAAI,CAACF,WAAL,CAAiBC,MAAjB,CAAP;AACH;;AAFDH;AAIA;;;;AAGA,SAAgBK,YAAhB,GAAqE;EAAA,IAAxCD,IAAwC,uEAAnBJ,2BAAmB;EACjE;EACA,MAAMM,GAAG,GAAGJ,WAAW,CAAC,CAAD,EAAIE,IAAJ,CAAvB,CAFiE,CAIjE;EACA;EACA;;EACA,MAAMG,MAAM,GAAG,2BAAaD,GAAb,CAAf,CAPiE,CASjE;;EACA,iBAAKA,GAAL;EAEA,OAAOC,MAAP;AACH;;AAbDP;AAeA;;AACA,MAAMQ,YAAY,GAAG,gEAArB;AAEA;;;;;;;;;;AASA,SAAgBC,YAAhB,CACIN,MADJ,EAG4C;EAAA,IADxCO,OACwC,uEAD9BF,YAC8B;EAAA,IAAxCJ,IAAwC,uEAAnBJ,2BAAmB;;EAExC,IAAIU,OAAO,CAACP,MAAR,GAAiB,CAArB,EAAwB;IACpB,MAAM,IAAIQ,KAAJ,CAAU,mCAAV,CAAN;EACH;;EACD,IAAID,OAAO,CAACP,MAAR,GAAiB,GAArB,EAA0B;IACtB,MAAM,IAAIQ,KAAJ,CAAU,kCAAV,CAAN;EACH;;EACD,IAAIC,GAAG,GAAG,EAAV;EACA,MAAMC,QAAQ,GAAGH,OAAO,CAACP,MAAzB;EACA,MAAMW,OAAO,GAAG,MAAO,MAAMD,QAA7B;;EACA,OAAOV,MAAM,GAAG,CAAhB,EAAmB;IACf,MAAMG,GAAG,GAAGJ,WAAW,CAACa,IAAI,CAACC,IAAL,CAAUb,MAAM,GAAG,GAAT,GAAeW,OAAzB,CAAD,EAAoCV,IAApC,CAAvB;;IACA,KAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,GAAG,CAACH,MAAR,IAAkBA,MAAM,GAAG,CAA3C,EAA8Cc,CAAC,EAA/C,EAAmD;MAC/C,MAAMC,UAAU,GAAGZ,GAAG,CAACW,CAAD,CAAtB;;MACA,IAAIC,UAAU,GAAGJ,OAAjB,EAA0B;QACtBF,GAAG,IAAIF,OAAO,CAACS,MAAR,CAAeD,UAAU,GAAGL,QAA5B,CAAP;QACAV,MAAM;MACT;IACJ;;IACD,iBAAKG,GAAL;EACH;;EACD,OAAOM,GAAP;AACH;;AA1BDZ;AA4BA;;;;;;;;;;;;;AAYA,SAAgBoB,sBAAhB,CACIC,IADJ,EAG4C;EAAA,IADxCX,OACwC,uEAD9BF,YAC8B;EAAA,IAAxCJ,IAAwC,uEAAnBJ,2BAAmB;EAExC,MAAMG,MAAM,GAAGY,IAAI,CAACC,IAAL,CAAUK,IAAI,IAAIN,IAAI,CAACO,GAAL,CAASZ,OAAO,CAACP,MAAjB,IAA2BY,IAAI,CAACQ,GAApC,CAAd,CAAf;EACA,OAAOd,YAAY,CAACN,MAAD,EAASO,OAAT,EAAkBN,IAAlB,CAAnB;AACH;;AAPDJ","names":["exports","system_1","randomBytes","length","prng","randomUint32","buf","result","ALPHANUMERIC","randomString","charset","Error","out","charsLen","maxByte","Math","ceil","i","randomByte","charAt","randomStringForEntropy","bits","log","LN2"],"sources":["C:\\Users\\USER\\Documents\\demo-react\\node_modules\\@stablelib\\random\\random.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package random provides functions to access system's\n * cryptographically secure random byte generator.\n */\n\nimport { RandomSource } from \"./source\";\nimport { SystemRandomSource } from \"./source/system\";\nimport { readUint32LE } from \"@stablelib/binary\";\nimport { wipe } from \"@stablelib/wipe\";\n\nexport { RandomSource } from \"./source\";\n\nexport const defaultRandomSource = new SystemRandomSource();\n\nexport function randomBytes(length: number, prng: RandomSource = defaultRandomSource): Uint8Array {\n    return prng.randomBytes(length);\n}\n\n/**\n * Returns a uniformly random unsigned 32-bit integer.\n */\nexport function randomUint32(prng: RandomSource = defaultRandomSource): number {\n    // Generate 4-byte random buffer.\n    const buf = randomBytes(4, prng);\n\n    // Convert bytes from buffer into a 32-bit integer.\n    // It's not important which byte order to use, since\n    // the result is random.\n    const result = readUint32LE(buf);\n\n    // Clean the buffer.\n    wipe(buf);\n\n    return result;\n}\n\n/** 62 alphanumeric characters for default charset of randomString() */\nconst ALPHANUMERIC = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n/**\n * Returns a uniform random string of the given length\n * with characters from the given charset.\n *\n * Charset must not have more than 256 characters.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nexport function randomString(\n    length: number,\n    charset = ALPHANUMERIC,\n    prng: RandomSource = defaultRandomSource\n): string {\n    if (charset.length < 2) {\n        throw new Error(\"randomString charset is too short\");\n    }\n    if (charset.length > 256) {\n        throw new Error(\"randomString charset is too long\");\n    }\n    let out = '';\n    const charsLen = charset.length;\n    const maxByte = 256 - (256 % charsLen);\n    while (length > 0) {\n        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);\n        for (let i = 0; i < buf.length && length > 0; i++) {\n            const randomByte = buf[i];\n            if (randomByte < maxByte) {\n                out += charset.charAt(randomByte % charsLen);\n                length--;\n            }\n        }\n        wipe(buf);\n    }\n    return out;\n}\n\n/**\n * Returns uniform random string containing at least the given\n * number of bits of entropy.\n *\n * For example, randomStringForEntropy(128) will return a 22-character\n * alphanumeric string, while randomStringForEntropy(128, \"0123456789\")\n * will return a 39-character numeric string, both will contain at\n * least 128 bits of entropy.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nexport function randomStringForEntropy(\n    bits: number,\n    charset = ALPHANUMERIC,\n    prng: RandomSource = defaultRandomSource\n): string {\n    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));\n    return randomString(length, charset, prng);\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive, PartType } from '../directive.js';\n\nclass ClassMapDirective extends Directive {\n  constructor(partInfo) {\n    var _a;\n\n    super(partInfo);\n\n    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== 'class' || ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {\n      throw new Error('`classMap()` can only be used in the `class` attribute ' + 'and must be the only part in the attribute.');\n    }\n  }\n\n  render(classInfo) {\n    // Add spaces to ensure separation from static classes\n    return ' ' + Object.keys(classInfo).filter(key => classInfo[key]).join(' ') + ' ';\n  }\n\n  update(part, _ref) {\n    let [classInfo] = _ref;\n\n    var _a, _b; // Remember dynamic classes on the first render\n\n\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(part.strings.join(' ').split(/\\s/).filter(s => s !== ''));\n      }\n\n      for (const name in classInfo) {\n        if (classInfo[name] && !((_a = this._staticClasses) === null || _a === void 0 ? void 0 : _a.has(name))) {\n          this._previousClasses.add(name);\n        }\n      }\n\n      return this.render(classInfo);\n    }\n\n    const classList = part.element.classList; // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that we don't require down-level\n    // iteration.\n\n    this._previousClasses.forEach(name => {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n\n        this._previousClasses.delete(name);\n      }\n    }); // Add or remove classes based on their classMap value\n\n\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n\n      if (value !== this._previousClasses.has(name) && !((_b = this._staticClasses) === null || _b === void 0 ? void 0 : _b.has(name))) {\n        if (value) {\n          classList.add(name);\n\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n\n    return noChange;\n  }\n\n}\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\n\n\nexport const classMap = directive(ClassMapDirective);","map":{"version":3,"mappings":"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","names":["noChange","directive","Directive","PartType","ClassMapDirective","constructor","partInfo","type","ATTRIBUTE","name","strings","_a","length","Error","render","classInfo","Object","keys","filter","key","join","update","part","_previousClasses","undefined","Set","_staticClasses","split","s","has","add","classList","element","forEach","remove","delete","value","_b","classMap"],"sources":["C:\\Users\\USER\\Documents\\demo-react\\node_modules\\lit-html\\src\\directives\\class-map.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of class names to truthy values.\n */\nexport interface ClassInfo {\n  readonly [name: string]: string | boolean | number;\n}\n\nclass ClassMapDirective extends Directive {\n  /**\n   * Stores the ClassInfo object applied to a given AttributePart.\n   * Used to unset existing values when a new ClassInfo object is applied.\n   */\n  private _previousClasses?: Set<string>;\n  private _staticClasses?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'class' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        '`classMap()` can only be used in the `class` attribute ' +\n          'and must be the only part in the attribute.'\n      );\n    }\n  }\n\n  render(classInfo: ClassInfo) {\n    // Add spaces to ensure separation from static classes\n    return (\n      ' ' +\n      Object.keys(classInfo)\n        .filter((key) => classInfo[key])\n        .join(' ') +\n      ' '\n    );\n  }\n\n  override update(part: AttributePart, [classInfo]: DirectiveParameters<this>) {\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(\n          part.strings\n            .join(' ')\n            .split(/\\s/)\n            .filter((s) => s !== '')\n        );\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !this._staticClasses?.has(name)) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n\n    const classList = part.element.classList;\n\n    // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that we don't require down-level\n    // iteration.\n    this._previousClasses.forEach((name) => {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses!.delete(name);\n      }\n    });\n\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (\n        value !== this._previousClasses.has(name) &&\n        !this._staticClasses?.has(name)\n      ) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {ClassMapDirective};\n"]},"metadata":{},"sourceType":"module"}